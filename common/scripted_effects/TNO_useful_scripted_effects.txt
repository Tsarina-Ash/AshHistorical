#	Various useful scripted effects
#
#
#
#	Moved Laws-related scriptedd effects to TNO_Laws_scripted_effects.txt  -Wendell08

# removes all current ministers (other than intel) for the country in scope - no tooltips displayed
remove_all_ministers = {
	hidden_effect = {
		remove_ideas_with_trait = head_of_government
		remove_ideas_with_trait = foreign_minister
		remove_ideas_with_trait = economy_minister
		remove_ideas_with_trait = security_minister
	}
}

#fill empty minister slots
fill_empty_minister = {
	if = {
		limit = {
			NOT = { has_idea_with_trait = head_of_government }
		}
		meta_effect = {
			text = {
				add_ideas = [currenttag]_Generic_Vacant_hog
			}
			currenttag = "[THIS.GetTag]"
		}
	}
	if = {
		limit = {
			NOT = { has_idea_with_trait = foreign_minister }
		}
		meta_effect = {
			text = {
				add_ideas = [currenttag]_Generic_Vacant_for
			}
			currenttag = "[THIS.GetTag]"
		}
	}
	if = {
		limit = {
			NOT = { has_idea_with_trait = security_minister }
		}
		meta_effect = {
			text = {
				add_ideas = [currenttag]_Generic_Vacant_sec
			}
			currenttag = "[THIS.GetTag]"
		}
	}
	if = {
		limit = {
			NOT = { has_idea_with_trait = economy_minister }
		}
		meta_effect = {
			text = {
				add_ideas = [currenttag]_Generic_Vacant_eco
			}
			currenttag = "[THIS.GetTag]"
		}
	}
}

# Should be used in history file only when a country doesn't have ministers for the rest of the game.
# If a country adds ministers in the middle of the game, add the effect and then remove the vacant positions when you're adding the minsiters
fill_empty_minister_nochecks = {
	meta_effect = {
		text = {
			add_ideas = {
				[currenttag]_Generic_Vacant_hog
				[currenttag]_Generic_Vacant_for
				[currenttag]_Generic_Vacant_sec
				[currenttag]_Generic_Vacant_eco
			}
		}
		currenttag = "[THIS.GetTag]"
	}
}

# changes the government of the country in scope to that of ROOT (the country running the event)

#adjust_research_modifier = {
#    #stolen with approval from Yard1
#	#thanks bb
#    set_temp_variable = { var_research_adjustment_pre_ironclad_temp = 1 }
#    set_variable = { var_research_adjustment_pre_ironclad = 1 }
#    subtract_from_variable = { var_research_adjustment_pre_ironclad = modifier@research_speed_factor }
#    if = {
#        limit = { check_variable = { var_research_adjustment_pre_ironclad = 0 } } # we don't want to divide by 0
#        add_to_variable = { var_research_adjustment_pre_ironclad = 0.001 }
#    }
#    divide_temp_variable = { var_research_adjustment_pre_ironclad_temp = var_research_adjustment_pre_ironclad }
#    set_variable = { var_research_adjustment_pre_ironclad = var_research_adjustment_pre_ironclad_temp }
#    subtract_from_variable = { var_research_adjustment_pre_ironclad = 1 }
#    subtract_from_variable = { var_research_adjustment_pre_ironclad = modifier@research_speed_factor }
#    add_dynamic_modifier = {
#        modifier = research_pre_ironclad_modifier
#    }
#}
#
#adjust_factory_output_modifier = {
#    set_temp_variable = { var_factory_adjustment_temp = 1 }
#    set_variable = { var_factory_adjustment = 1 }
#    subtract_from_variable = { var_factory_adjustment = modifier@industrial_capacity_factory }
#    if = {
#        limit = { check_variable = { var_factory_adjustment = 0 } } # we don't want to divide by 0
#        add_to_variable = { var_factory_adjustment = 0.001 }
#    }
#    divide_temp_variable = { var_factory_adjustment_temp = var_factory_adjustment }
#    set_variable = { var_factory_adjustment = var_factory_adjustment_temp }
#    subtract_from_variable = { var_factory_adjustment = 1 }
#    subtract_from_variable = { var_factory_adjustment = modifier@industrial_capacity_factory }
#    add_dynamic_modifier = {
#        modifier = factory_output_modifier
#    }
#}
#
#adjust_dockyard_output_modifier = {
#    set_temp_variable = { var_dockyard_adjustment_temp = 1 }
#    set_variable = { var_dockyard_adjustment = 1 }
#    subtract_from_variable = { var_dockyard_adjustment = modifier@industrial_capacity_dockyard }
#    if = {
#        limit = { check_variable = { var_dockyard_adjustment = 0 } } # we don't want to divide by 0
#        add_to_variable = { var_dockyard_adjustment = 0.001 }
#    }
#    divide_temp_variable = { var_dockyard_adjustment_temp = var_dockyard_adjustment }
#    set_variable = { var_dockyard_adjustment = var_dockyard_adjustment_temp }
#    subtract_from_variable = { var_dockyard_adjustment = 1 }
#    subtract_from_variable = { var_dockyard_adjustment = modifier@industrial_capacity_dockyard }
#    add_dynamic_modifier = {
#        modifier = dockyard_output_modifier
#    }
#}
#
#adjust_construction_speed_modifier = {
#    set_temp_variable = { var_construction_adjustment_temp = 1 }
#    set_variable = { var_construction_adjustment = 1 }
#    subtract_from_variable = { var_construction_adjustment = modifier@production_speed_buildings_factor }
#    if = {
#        limit = { check_variable = { var_construction_adjustment = 0 } } # we don't want to divide by 0
#        add_to_variable = { var_construction_adjustment = 0.001 }
#    }
#    divide_temp_variable = { var_construction_adjustment_temp = var_construction_adjustment }
#    set_variable = { var_construction_adjustment = var_construction_adjustment_temp }
#    subtract_from_variable = { var_construction_adjustment = 1 }
#    subtract_from_variable = { var_construction_adjustment = modifier@production_speed_buildings_factor }
#    add_dynamic_modifier = {
#        modifier = construction_speed_modifier
#    }
#}

# adjust_efficiency_cap_modifier = {
# 	set_temp_variable = { var_efficiency_cap_adjustment_temp = modifier@production_factory_max_efficiency_factor }
# 	add_to_temp_variable = { var_efficiency_cap_adjustment_temp = -0.05 }
# 	set_variable = { var_efficiency_cap_adjustment = 0 }
# 	subtract_from_variable = { var_efficiency_cap_adjustment = var_efficiency_cap_adjustment_temp }
# 	add_dynamic_modifier = {
# 		modifier = efficiency_cap_modifier
# 	}
# }

TNO_div_limiter_calculate_unit_cap = {
	set_variable = { TNOLimiterIndustry = production_units }
	multiply_variable = { TNOLimiterIndustry = 1.5 }
	multiply_variable = { TNOLimiterIndustry = DivLimiterEscalatorPerm }
	#else_if = {
	#	limit = {
	#		tag = JAP
	#		has_war = no
	#	}
	#	divide_variable = { TNOLimiterIndustry = 7.1 }
	#}
	#else_if = {
	#	limit = {
	#		tag = ITA
	#	}
	#	divide_variable = { TNOLimiterIndustry = 5 }
	#}
	#else_if = {
	#	limit = {
	#		tag = GER
	#	}
	#	divide_variable = { TNOLimiterIndustry = 1.9 }
	#}
	if = {  #Caps unit production based on PUs
		limit = {
			has_war = no
			OR = {
				check_variable = { num_divisions > TNOLimiterIndustry }
				check_variable = { num_divisions = TNOLimiterIndustry }
			}
		}
		set_country_flag = TNO_DIVISIONS_CAPPED
	}
	if = {
		limit = {
			check_variable = { num_divisions < TNOLimiterIndustry }
			has_country_flag = TNO_DIVISIONS_CAPPED
		}
		clr_country_flag = TNO_DIVISIONS_CAPPED
	}
}

TNO_div_limiter_escalator_mechanism_run = {
	THIS = {
		set_variable = { DivLimiterEscalatorPerm = 1 }
		every_neighbor_country = {
			set_variable = { THIS.DivLimiterEscalator = THIS.num_divisions }
			divide_variable = { THIS.DivLimiterEscalator = PREV.num_divisions }
			if = {
				limit = { check_variable = { THIS.DivLimiterEscalator > PREV.DivLimiterEscalatorPerm} }
				set_variable = { PREV.DivLimiterEscalatorPerm = THIS.DivLimiterEscalator }
			}
		}
		log = "[GetDateText]: [THIS.GetName]: ran Division Limiter Escalator script - current permanent escalator value is [?DivLimiterEscalatorPerm] - current limiter value is [?TNOLimiterIndustry]"
	}
}

TNO_cancel_border_war_country_scope = {
	every_owned_state = {
		limit = {
			has_border_war = yes
		}
		every_neighbor_state = {
			limit = {
				has_border_war = yes
			}
			if = {
				limit = {
					has_border_war_between = {
						attacker = THIS
						defender = PREV
					}
				}
				cancel_border_war = {
					dont_fire_events = yes
					defender = PREV
					attacker = THIS
				}
				log = "[GetDateText]: [Root.GetName]: ABORTED BORDER WAR BETWEEN [THIS.GetName] AND [PREV.GetName]"
			}
			if = {
				limit = {
					has_border_war_between = {
						attacker = PREV
						defender = THIS
					}
				}
				cancel_border_war = {
					dont_fire_events = yes
					defender = THIS
					attacker = PREV
				}
				log = "[GetDateText]: [Root.GetName]: ABORTED BORDER WAR BETWEEN [PREV.GetName] AND [THIS.GetName]"
			}
		}
	}
}

TNO_cancel_border_war_state_scope = {
	every_neighbor_state = {
		limit = {
			has_border_war = yes
		}
		if = {
			limit = {
				has_border_war_between = {
					attacker = THIS
					defender = PREV
				}
			}
			cancel_border_war = {
				dont_fire_events = yes
				defender = PREV
				attacker = THIS
			}
			log = "[GetDateText]: [Root.GetName]: ABORTED BORDER WAR BETWEEN [THIS.GetName] AND [PREV.GetName]"
		}
		if = {
			limit = {
				has_border_war_between = {
					attacker = PREV
					defender = THIS
				}
			}
			cancel_border_war = {
				dont_fire_events = yes
				defender = THIS
				attacker = PREV
			}
			log = "[GetDateText]: [Root.GetName]: ABORTED BORDER WAR BETWEEN [PREV.GetName] AND [THIS.GetName]"
		}
	}
}

# Puppeting a country completly fucks up party popularities, thanks PDX
# Use both effects on the same scope
save_party_popularities = { # Use this before puppeting
	log = "[GetDateText]: [THIS.GetName]: Running save_party_popularities command"
	set_temp_variable = { PartyPopTotal = 0 }
	add_to_array = { PartyPops = party_popularity@communist }
	add_to_array = { PartyPops = party_popularity@socialist }
	add_to_array = { PartyPops = party_popularity@social_democracy }
	add_to_array = { PartyPops = party_popularity@liberal_democracy }
	add_to_array = { PartyPops = party_popularity@conservative_democracy }
	add_to_array = { PartyPops = party_popularity@authoritarian_democracy }
	add_to_array = { PartyPops = party_popularity@despotism }
	add_to_array = { PartyPops = party_popularity@fascism }
	add_to_array = { PartyPops = party_popularity@national_socialism }
	add_to_array = { PartyPops = party_popularity@ultranationalism }
	add_to_array = { PartyPops = party_popularity@esoteric_nazism }

	for_each_loop = {
		array = PartyPops
		multiply_variable = { PartyPops^i = 100 }
		round_variable = PartyPops^i
		add_to_temp_variable = { PartyPopTotal = PartyPops^i }
	}

	if = {
		limit = { check_variable = { PartyPopTotal > 100 } }
		subtract_from_temp_variable = { PartyPopTotal = 100 }
		log = "[GetDateText]: [THIS.GetName]: PartyPop value exceeds 100 - [?PartyPopTotal]"
		for_each_loop = {
			array = PartyPop
			if = {
				limit = { check_variable = { PartyPop^i > PartyPopTotal } }
				subtract_from_variable = { PartyPop^i = PartyPopTotal }
				add_to_temp_variable = { break = 1 }
			}
		}
	}
	else_if = {
		limit = { check_variable = { PartyPopTotal < 100 } }
		subtract_from_temp_variable = { PartyPopTotal = 100 }
		multiply_temp_variable = { PartyPopTotal = -1 }
		log = "[GetDateText]: [THIS.GetName]: PartyPop value is less than 100 - [?PartyPopTotal]"
		set_temp_variable = { a = 0 }
		randomize_temp_variable = {
			var = a
			distribution = uniform
			min = 0
			max = 11
		}
		round_temp_variable = a
		add_to_variable = { PartyPop^a = PartyPopTotal }
	}
}

apply_party_popularities = { # Use this after puppeting
	hidden_effect = {
		set_popularities = {
			communist = PartyPops^0
			socialist = PartyPops^1
			social_democracy = PartyPops^2
			liberal_democracy = PartyPops^3
			conservative_democracy = PartyPops^4
			authoritarian_democracy = PartyPops^5
			despotism = PartyPops^6
			fascism = PartyPops^7
			national_socialism = PartyPops^8
			ultranationalism = PartyPops^9
			esoteric_nazism = PartyPops^10
		}
		clear_array = PartyPops
	}
}

# Babylonian (Newton) method of finding square roots by Yard1 (https://hackmd.io/@Yard1/B1w3sRCNv)
# Feel free to use and modify provided credits are given

# # Finding the square root of 10.
# set_variable = { sr_arg_number = 10 } # Put 10 into the argument variable
# square_root_number = yes # Run the effect
# set_variable = { out = sr_ret_number } # Set your out variable to the return variable

# Square roots a number (sr_arg_number), returns value in sr_ret_number.
square_root_babylonian = {
	if = {
		limit = {
			check_variable = { sr_arg_number < 0.001 }
		}
		set_variable = { sr_ret_number = 0 }
	}
	else = {
		# overflow at 2147483.647
		# therefore, highest possible square root * 2 is ~2931
		set_temp_variable = { x = 2931 }

		set_temp_variable = { y = 1 }
		set_temp_variable = { e = 0.001 } # precision - game can't go any lower than this
		while_loop_effect = {
			limit = {
				set_temp_variable = { t_x = x }
				subtract_from_temp_variable = { t_x = y }
				check_variable = { t_x > e }
			}
			add_to_temp_variable = { x = y }
			divide_temp_variable = { x = 2 }
			set_temp_variable = { y = sr_arg_number }
			divide_temp_variable = { y = x }
		}
		set_variable = { sr_ret_number = x }
	}
}
